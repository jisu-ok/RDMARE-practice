#include <infiniband/verbs.h>
//#include <infiniband/verbs_exp.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include "get_clock.h"
// #include <math.h>

// options
// #define SEND_SIGNALING
// #define SEND_INLINING

#define PORT_NUM 1
#define ENTRY_SIZE 9000 /* maximum size of each packet buffer */
#define SQ_NUM_DESC 512 /* maximum number of sends waiting for completion */
#define RQ_NUM_DESC 512 /* The maximum receive ring length without processing */

#define MAC_SANCTUARY {0x24, 0x8A, 0x07, 0x91, 0x69, 0xA0}
#define MAC_MOSCOW {0x24, 0x8A, 0x07, 0x91, 0x68, 0xE8}

/* template of packet to send - in this case icmp */

// #define DST_MAC 0x00, 0x01, 0x02, 0x03, 0x04, 0x05 // 6 bytes
// #define SRC_MAC 0xe4, 0x1d, 0x2d, 0xf3, 0xdd, 0xcc // 6 bytes
#define ETH_TYPE 0x08, 0x00 // 2 bytes
#define IP_HDRS 0x45, 0x00, 0x00, 0x54, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0xaf, 0xb6 // 12 bytes
// #define IP_HDRS 0x45, 0x00, 0x05, 0xdc, 0x00, 0x00, 0x40, 0x00, 0x40, 0x01, 0xaa, 0x2e // 12 bytes
#define SRC_IP 0x0d, 0x07, 0x38, 0x66 // 4 bytes
#define DST_IP 0x0d, 0x07, 0x38, 0x7f // 4 bytes
#define IP_OPT 0x08, 0x00, 0x59, 0xd0, 0x88 // 5 bytes
#define ICMP_HDR 0x2c, 0x00, 0x09, 0x52, 0xae, 0x96, 0x57, 0x00, 0x00 // 9 bytes

#define TCP_SPORT 0x00, 0x03
#define TCP_DPORT 0x03, 0x00
#define TCP_SEQ 0x00, 0x00, 0x01, 0x00
#define TCP_ACK 0x00, 0x01, 0x00, 0x00
#define TCP_HDR 0x00, 0x02, 0x02, 0x00, 0xAA, 0xAA, 0x00, 0x00

char packet[] = {
    0x24, 0x8A, 0x07, 0x91, 0x68, 0xE8, // dst: MAC_MOSCOW
    0x24, 0x8A, 0x07, 0x91, 0x69, 0xA0, // src: MAC_SANCTUARY
    ETH_TYPE, IP_HDRS, SRC_IP, DST_IP, IP_OPT, ICMP_HDR,
    0x00, 0x00, 0x62, 0x21, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
    0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
    0x36, 0x37, }; // 6 + 6 + 2 + 12 + 4 + 4 + 5 + 9 + 50 = 98 bytes

// char packet[1514] = {
//     0x24, 0x8A, 0x07, 0x91, 0x68, 0xE8, // dst: MAC_MOSCOW
//     0x24, 0x8A, 0x07, 0x91, 0x69, 0xA0, // src: MAC_SANCTUARY
//     ETH_TYPE,
//     IP_HDRS, SRC_IP, DST_IP,
//     TCP_SPORT, TCP_DPORT, TCP_SEQ, TCP_ACK, TCP_HDR,
//     0x00, 0x00, 0x62, 0x21, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
//     0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
//     0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
//     0x36, 0x37, };



// char packet[] = {
//     // 0xb4, 0x2e, 0x99, 0xf9, 0xf4, 0x2e,
//     // 0xac, 0x4b, 0xc8, 0x9f, 0xf6, 0x01,
//     // 0x08, 0x00,
//     0x24, 0x8A, 0x07, 0x91, 0x68, 0xE8, // dst: MAC_MOSCOW
//     0x24, 0x8A, 0x07, 0x91, 0x69, 0xA0, // src: MAC_SANCTUARY
//     ETH_TYPE,
//     0x45, 0x00, 0x05, 0xdc,
//     0xd9, 0x34, 0x40, 0x00,
//     0x35, 0x06, 0xe9, 0x05,
//     0x2b, 0xfa, 0x98, 0x2a,
//     0x8f, 0xf8, 0x29, 0xc5,
//     0x01, 0xbb, 0xec, 0x75, 0xee, 0x05, 0x7d, 0xd8, 0x33, 0x04, 0x73, 0xdf, 0x50, 0x10, 0x01, 0x28, 0x50, 0xe2, 0x00, 0x00,
//     0xd4, 0xde, 0x0e, 0x02, 0x50, 0x25, 0xa4, 0x84, 0xb3, 0x29, 0x2e, 0xe6, 0x4c, 0x0f, 0x6e, 0x2f,
//     0x15, 0x97, 0x65, 0x50, 0x06, 0x29, 0x35, 0xf1, 0xc6, 0x30, 0xac, 0x58, 0x1f, 0x82, 0xc4, 0xe0,
//     0xa8, 0x35, 0xf5, 0x4b, 0xa3, 0x91, 0xf4, 0x4f, 0xf2, 0x01, 0x85, 0x8a, 0xd5, 0x63, 0x8a, 0xa7,
//     0xf0, 0xa8, 0x38, 0xc8, 0x76, 0x41, 0x7e, 0xb0, 0xc7, 0xf4, 0xaf, 0x8b, 0x20, 0x2e, 0x99, 0x7d,
//     0x72, 0x1e, 0x8e, 0x83, 0x20, 0x68, 0x40, 0x64, 0x4e, 0x84, 0xe6, 0x13, 0x81, 0x38, 0x46, 0x60,
//     0x89, 0x61, 0x86, 0xcb, 0x2b, 0x39, 0xad, 0x3e, 0x50, 0xab, 0xb9, 0x1d, 0xe7, 0xe1, 0x19, 0x16,
//     0xf4, 0xf1, 0xc3, 0xef, 0x31, 0xe6, 0x7a, 0x17, 0x47, 0x5d, 0x83, 0xac, 0x64, 0x9c, 0x04, 0xea,
//     0xcc, 0xae, 0x11, 0x1d, 0x7a, 0x97, 0x3f, 0x37, 0xe0, 0xc8, 0xe6, 0x86, 0x4c, 0xef, 0x10, 0xb7,
//     0xe0, 0x61, 0xe5, 0xfa, 0x0b, 0x38, 0xbb, 0xfd, 0x13, 0x7a, 0x37, 0x27, 0x6f, 0x06, 0xe0, 0xf3,
//     0x39, 0x51, 0x76, 0xee, 0xcb, 0x72, 0x40, 0x01, 0x18, 0xa1, 0xe0, 0x4a, 0x81, 0x01, 0x48, 0x3f,
//     0xa2, 0x46, 0x51, 0x90, 0x2a, 0xfd, 0x79, 0xf5, 0x05, 0x24, 0xa7, 0x4d, 0x45, 0x98, 0x9d, 0x5e,
//     0x8b, 0x5f, 0x9c, 0xd1, 0x9b, 0xc1, 0xd3, 0xd6, 0x4f, 0x1b, 0xd3, 0x76, 0xd6, 0xf5, 0x28, 0xe7,
//     0x8e, 0x8d, 0x94, 0xd6, 0x21, 0x53, 0x36, 0xc6, 0x12, 0x19, 0x93, 0xd4, 0xfe, 0xae, 0x2f, 0xdf,
//     0x85, 0x35, 0x6d, 0xdc, 0x22, 0xde, 0x23, 0x9f, 0xa9, 0x77, 0x22, 0xb3, 0x24, 0xf3, 0x1c, 0x11,
//     0xe9, 0xe1, 0x20, 0x44, 0x6e, 0x10, 0x4d, 0xfd, 0x82, 0x63, 0xe5, 0x3a, 0xf8, 0x33, 0xbb, 0xe8,
//     0x15, 0x29, 0xb6, 0x81, 0x2d, 0xa2, 0x74, 0x58, 0x6d, 0x8b, 0x3c, 0x21, 0x93, 0x62, 0xc8, 0x18,
//     0xe2, 0x48, 0xcd, 0xdf, 0x64, 0x6c, 0x88, 0x63, 0xc3, 0x9c, 0xb6, 0x41, 0xf1, 0xdd, 0xbc, 0xf4,
//     0xb3, 0x1d, 0xa2, 0x31, 0x72, 0xfe, 0x71, 0xd6, 0x9b, 0x21, 0x8e, 0x58, 0x9f, 0xda, 0x46, 0xb9,
//     0x3f, 0x81, 0x45, 0xb2, 0x4a, 0xba, 0x18, 0x95, 0x1f, 0xcd, 0xfd, 0x9f, 0x2a, 0xa1, 0xb4, 0xea,
//     0xef, 0x65, 0x6a, 0x7e, 0x47, 0xa8, 0xa2, 0xdb, 0x85, 0x2b, 0x24, 0x0d, 0x74, 0xf0, 0x89, 0x90,
//     0x32, 0x02, 0x46, 0xd7, 0x15, 0xfe, 0x30, 0x13, 0xd0, 0xe3, 0x24, 0x76, 0xde, 0x0c, 0x33, 0x51,
//     0x31, 0x3c, 0xb6, 0x00, 0xa7, 0xad, 0x66, 0x27, 0xf1, 0x32, 0xd4, 0x70, 0xd1, 0x18, 0xdf, 0xa8,
//     0xe8, 0xdc, 0x07, 0x3f, 0xb9, 0x3e, 0xb9, 0xcd, 0x62, 0xd0, 0xf1, 0x7e, 0x4f, 0x5b, 0x01, 0x91,
//     0x03, 0xfe, 0xba, 0x97, 0xdd, 0xb5, 0x53, 0x7b, 0xa3, 0x9d, 0xe3, 0x40, 0x3b, 0xe9, 0xf0, 0xb0,
//     0xc1, 0x0d, 0x4e, 0xaf, 0x43, 0x4d, 0x64, 0x29, 0x6e, 0xcf, 0x17, 0x1a, 0xb5, 0xed, 0x57, 0xf1,
//     0xcf, 0x31, 0x1c, 0x7b, 0xb3, 0x70, 0x5f, 0x25, 0x74, 0x93, 0xc6, 0x20, 0x32, 0xce, 0x23, 0x4b,
//     0x29, 0xf6, 0x03, 0x58, 0x18, 0x47, 0x92, 0x40, 0xc2, 0xe9, 0x48, 0xf2, 0xef, 0x48, 0xa5, 0xe0,
//     0xc6, 0x6e, 0x30, 0xf0, 0xf3, 0x96, 0x4b, 0xe3, 0x07, 0xfe, 0x08, 0x56, 0xac, 0xe6, 0xca, 0x6a,
//     0xc4, 0xba, 0xbf, 0x22, 0xc4, 0x0c, 0x4e, 0x9d, 0x88, 0xf3, 0xaa, 0x7a, 0x4a, 0xff, 0x27, 0x84,
//     0x02, 0x9c, 0xc4, 0xfe, 0x48, 0xaa, 0x52, 0x96, 0x96, 0x2e, 0xb9, 0xe7, 0xe3, 0x4b, 0xe3, 0x3f,
//     0x6f, 0x44, 0x96, 0x33, 0x40, 0xd8, 0x51, 0x56, 0x9d, 0xee, 0xcd, 0xa3, 0x24, 0x8d, 0x2c, 0xad,
//     0x7f, 0x90, 0xa4, 0x4c, 0xbc, 0x14, 0xa2, 0x7d, 0x02, 0xf4, 0xb7, 0x7a, 0xc1, 0xf3, 0xa9, 0xe9,
//     0x98, 0x92, 0x55, 0xcc, 0x89, 0x5a, 0x35, 0x82, 0xad, 0x42, 0x9d, 0x41, 0x29, 0xf5, 0x45, 0x6e,
//     0xc4, 0x6b, 0x75, 0xa9, 0xaa, 0xe5, 0x10, 0x33, 0x49, 0x0b, 0xc4, 0x7e, 0x4a, 0xab, 0xd4, 0xc0,
//     0xb8, 0x7a, 0xf4, 0xe0, 0x24, 0x68, 0xf6, 0xd2, 0x58, 0xa7, 0x7f, 0x14, 0xb6, 0xf2, 0x9b, 0x18,
//     0xd2, 0xae, 0x3d, 0x5c, 0x74, 0x6d, 0xea, 0x35, 0x7f, 0xfe, 0xd4, 0x8a, 0x9b, 0x3e, 0x43, 0x6b,
//     0xb1, 0xcc, 0x97, 0x43, 0x17, 0x54, 0xb3, 0x44, 0x8d, 0xd9, 0x00, 0x29, 0xab, 0x9f, 0xfa, 0x08,
//     0x79, 0xff, 0x0f, 0x5b, 0x88, 0xdd, 0xbc, 0x62, 0xa2, 0x64, 0x7e, 0x0b, 0xf0, 0x79, 0x0c, 0x6a,
//     0xa0, 0x3c, 0xb1, 0x27, 0x13, 0x51, 0x7d, 0x88, 0x5f, 0x79, 0x8b, 0x83, 0x9a, 0x69, 0xea, 0x23,
//     0x23, 0xea, 0xa5, 0xd6, 0xdf, 0x65, 0x84, 0x31, 0x94, 0xa4, 0x17, 0x5e, 0xe7, 0xb5, 0x87, 0x19,
//     0x7c, 0x9c, 0xf0, 0x3b, 0x1f, 0xb2, 0x0d, 0x1e, 0x2c, 0x69, 0xdd, 0x08, 0x9e, 0x85, 0x69, 0x0d,
//     0xe8, 0xa6, 0xfc, 0x94, 0x3d, 0xba, 0x1c, 0x5d, 0x84, 0xfc, 0xd6, 0xf3, 0xdc, 0xd5, 0x04, 0x9e,
//     0xa6, 0xdb, 0x00, 0x9e, 0x2f, 0x8b, 0x51, 0x5e, 0xaa, 0x08, 0xaa, 0x59, 0x5e, 0xe2, 0x9e, 0xb5,
//     0x91, 0x9b, 0x6d, 0xa1, 0xee, 0x85, 0xae, 0x23, 0xae, 0x0f, 0x1f, 0x50, 0x85, 0x79, 0xe4, 0x94,
//     0x88, 0x65, 0x8c, 0x2b, 0xf2, 0xdf, 0xcc, 0xc9, 0x06, 0x96, 0xbf, 0x4b, 0xc0, 0x6b, 0x63, 0x8d,
//     0x1e, 0x15, 0x8d, 0x26, 0xaf, 0xdb, 0x43, 0x37, 0xbf, 0x99, 0xb8, 0xfb, 0xb3, 0x60, 0xd3, 0x72,
//     0x7f, 0x54, 0x21, 0xb7, 0xdd, 0x88, 0x98, 0x1a, 0x4e, 0x4f, 0xe5, 0xa1, 0x8f, 0x80, 0xec, 0xaf,
//     0x51, 0x8c, 0xe3, 0x60, 0xb7, 0x01, 0xbb, 0x08, 0x72, 0x64, 0x85, 0x25, 0x7f, 0x5f, 0x2c, 0x7f,
//     0x91, 0x47, 0x6a, 0x9d, 0x71, 0x16, 0xc9, 0xe1, 0x16, 0x3e, 0xe8, 0xe5, 0x31, 0x9a, 0x81, 0x7f,
//     0x38, 0x64, 0x4f, 0x43, 0x40, 0x87, 0x74, 0x09, 0x07, 0x22, 0xb6, 0xfe, 0x8d, 0x8e, 0x71, 0x3b,
//     0xec, 0x73, 0xbf, 0xb3, 0x5c, 0x23, 0x7c, 0x02, 0x5c, 0x89, 0x7a, 0xc3, 0x4b, 0x3c, 0x1e, 0xea,
//     0x0c, 0x75, 0x01, 0x14, 0x64, 0x39, 0x76, 0x6e, 0x55, 0x38, 0xc1, 0xd1, 0xb0, 0x90, 0x91, 0xd3,
//     0xcd, 0x78, 0x9e, 0x20, 0xf9, 0xea, 0xcd, 0x68, 0x85, 0x40, 0x7c, 0x95, 0x5e, 0x98, 0x03, 0x45,
//     0x76, 0xd6, 0x2a, 0x2f, 0x77, 0xa7, 0x23, 0xf1, 0xaf, 0x5e, 0x09, 0x6e, 0xf7, 0x0f, 0x0f, 0x47,
//     0x68, 0x26, 0xc9, 0xaf, 0x8f, 0x19, 0x12, 0xca, 0x13, 0x0f, 0xff, 0x30, 0x5c, 0xfb, 0x09, 0xba,
//     0x2f, 0x45, 0x2f, 0x59, 0x6c, 0x64, 0x70, 0xef, 0x05, 0x79, 0x0f, 0xb2, 0x88, 0x4c, 0xd3, 0x0d,
//     0x7c, 0xdf, 0x1b, 0xa2, 0x27, 0xcc, 0x21, 0x53, 0x1d, 0x6a, 0xa8, 0xfd, 0x8f, 0xad, 0x22, 0x70,
//     0x59, 0xff, 0xf3, 0x4d, 0xac, 0x9e, 0xad, 0xb8, 0xff, 0xbf, 0x21, 0x4c, 0x9b, 0x36, 0xdb, 0x6c,
//     0x9b, 0x34, 0xdf, 0xc7, 0xa3, 0x50, 0x36, 0x2b, 0x0a, 0xac, 0xc5, 0x49, 0x31, 0xb5, 0x31, 0xe0,
//     0xe0, 0xd8, 0xc9, 0x11, 0x99, 0x5e, 0x86, 0x41, 0xf3, 0x1b, 0x16, 0x8a, 0xcb, 0x04, 0x36, 0xba,
//     0x9c, 0x7c, 0xbb, 0xcb, 0x9f, 0x12, 0xe6, 0xc5, 0xae, 0x64, 0xbd, 0xca, 0x99, 0x56, 0x5f, 0x19,
//     0xa1, 0x07, 0xee, 0x5b, 0x19, 0x67, 0x59, 0x41, 0x0c, 0x3d, 0x33, 0x3c, 0x85, 0x64, 0xc0, 0x23,
//     0x73, 0x82, 0xbc, 0xdb, 0xd3, 0x42, 0x3e, 0x67, 0xa1, 0x99, 0x85, 0x5f, 0x1f, 0x4b, 0xc6, 0xcd,
//     0x5c, 0x0f, 0xe9, 0x6c, 0x9e, 0x6f, 0xef, 0x0b, 0x68, 0x3d, 0x36, 0x7b, 0x5c, 0x41, 0xce, 0x46,
//     0x8f, 0xc7, 0xe5, 0x56, 0xf9, 0x91, 0xc2, 0x51, 0xfb, 0xd0, 0x85, 0xb2, 0x0d, 0x2a, 0x18, 0x0e,
//     0x51, 0xf3, 0xef, 0x98, 0xe6, 0x71, 0x69, 0x66, 0x2f, 0xef, 0x4e, 0xa6, 0x0a, 0x44, 0x6e, 0x56,
//     0x4a, 0x8d, 0x80, 0x31, 0x6f, 0xb6, 0xa6, 0x26, 0x85, 0xc9, 0xa1, 0x04, 0xcc, 0x45, 0xdf, 0x00,
//     0x72, 0x06, 0x02, 0x74, 0xed, 0xbe, 0x67, 0x43, 0x08, 0xf4, 0x02, 0xe7, 0x37, 0x9a, 0x59, 0x63,
//     0x25, 0x0e, 0x6b, 0x01, 0xda, 0xff, 0x1d, 0x7a, 0xd7, 0x68, 0xa7, 0x78, 0xdf, 0x61, 0xc0, 0x59,
//     0xba, 0x4a, 0xce, 0x5e, 0x4b, 0xfb, 0x47, 0x41, 0x3e, 0xea, 0x11, 0xfa, 0x68, 0xdf, 0x78, 0x40,
//     0x2a, 0x6c, 0x4e, 0x8c, 0x38, 0x48, 0xa7, 0x40, 0x25, 0xac, 0xa4, 0x39, 0x40, 0x7e, 0xdd, 0x6d,
//     0xe6, 0xc0, 0xd3, 0x25, 0xec, 0x87, 0xea, 0xf6, 0x4d, 0x03, 0x86, 0xcc, 0x32, 0x38, 0x79, 0x88,
//     0x71, 0x1e, 0xc1, 0x87, 0xb8, 0x49, 0xd6, 0x11, 0xb8, 0xf9, 0xd4, 0xb5, 0x46, 0x0d, 0x1c, 0x12,
//     0xab, 0x22, 0x91, 0xf4, 0x13, 0x5a, 0xeb, 0x4a, 0x30, 0x71, 0x9d, 0xea, 0x30, 0xec, 0x18, 0xe5,
//     0xfc, 0x37, 0x14, 0xb3, 0xea, 0x77, 0xed, 0x03, 0x2e, 0xed, 0x68, 0x74, 0xd4, 0x07, 0x77, 0xf1,
//     0xe1, 0x31, 0x7c, 0xcb, 0xb3, 0x49, 0x04, 0xd0, 0x4d, 0xc6, 0x78, 0xd3, 0x46, 0xa5, 0x68, 0x74,
//     0x31, 0x11, 0x95, 0x18, 0x05, 0x5a, 0x19, 0x87, 0x94, 0xbc, 0xc3, 0x25, 0x9e, 0x33, 0xf2, 0x4d,
//     0x8e, 0x9d, 0x9d, 0x8f, 0xc4, 0x1d, 0x85, 0x2a, 0xe5, 0x4f, 0x72, 0x64, 0xc9, 0xa2, 0x70, 0xd0,
//     0xcd, 0x5e, 0x2c, 0xc2, 0x4e, 0x4b, 0x25, 0x3b, 0x3d, 0x3f, 0x41, 0xf0, 0xc3, 0xb4, 0x78, 0xbc,
//     0x83, 0x4c, 0xa7, 0x6f, 0x4f, 0xc7, 0x9a, 0xc7, 0x4b, 0x90, 0xe3, 0x60, 0x31, 0x01, 0x7c, 0x63,
//     0x05, 0xad, 0x25, 0xa9, 0x2d, 0x42, 0x6b, 0x8e, 0x53, 0x57, 0x58, 0x2d, 0x8b, 0x4e, 0xdd, 0x7c,
//     0x07, 0x62, 0x9b, 0xe6, 0x73, 0xb3, 0x8b, 0xfb, 0x3e, 0xda, 0x10, 0x8e, 0x89, 0x2b, 0x61, 0xdc,
//     0xc0, 0x8b, 0x42, 0xfa, 0xfe, 0x19, 0x0a, 0xf2, 0xa1, 0xaf, 0xb3, 0x15, 0xda, 0x72, 0x66, 0x8c,
//     0x16, 0xf2, 0x5f, 0x72, 0xae, 0x36, 0xc3, 0xce, 0xad, 0xff, 0x0f, 0x8b, 0x43, 0x5f, 0x7f, 0x63,
//     0x64, 0xd3, 0x86, 0x21, 0x5c, 0x7a, 0xfc, 0x15, 0x4b, 0x30, 0x28, 0x95, 0xf8, 0x29, 0x03, 0xd8,
//     0xab, 0xd2, 0x0a, 0xc0, 0x8a, 0x7e, 0x82, 0x95, 0xa9, 0xbc, 0xbd, 0x9f, 0xad, 0xb7, 0x02, 0x3e,
//     0xd5, 0x6b, 0x66, 0x74, 0xa2, 0x62, 0x7c, 0xb6, 0xb5, 0xf2, 0xde, 0x25, 0x05, 0xe9, 0xf6, 0xb2,
//     0x59, 0x25, 0x40, 0x52, 0x4a, 0xd7, 0x00, 0x24, 0x51, 0x03, 0xd5, 0x8b, 0x09, 0xc8, 0x69, 0xa2,
//     0xe2, 0x28, 0x20, 0xd0, 0x48, 0x84, 0xd7, 0xef, 0x1e, 0x5a, 0x3b, 0xc6, 0x18, 0xfa, 0x9e, 0x0a,
//     0x0f, 0x48, 0x55, 0x4d, 0x84, 0xe8, 0x07, 0xc1, 0xa6, 0xb5, 0x87, 0x92, 0xfe, 0x3b, 0x6d, 0xd6,
//     0x10, 0x5f, 0x1c, 0xd3, 0x1b, 0x9f, 0x5e, 0x53, 0xdf, 0xe9, 0xdf, 0x0f, 0x03, 0x97, 0xc3, 0x14, 0x46, 0xc6, 0x76, 0xb8,
// };


int time_diff_nsec(struct timespec t1, struct timespec t2) {
    return (t2.tv_nsec - t1.tv_nsec) + 1000000000 * (t2.tv_sec - t1.tv_sec);
}

int compare(const void *a, const void *b) {
    double num1 = *(double *)a;
    double num2 = *(double *)b;

    if (num1 < num2)
        return -1;

    if (num1 > num2)
        return 1;

    return 0;
}

double median(double *vals, int n) {
    if (n % 2 == 1) // odd number of elements
        return vals[(n-1) / 2];
    else // even number of elements
        return (vals[n/2 - 1] + vals[n/2]) / 2;
}

// double calc_mean(int* vals, int n) {
//     int sum = 0;
//     for (int i=0; i < n; i++)
//         sum += vals[i];
//     return (double) sum / (double) n;
// }

// double calc_stdev(int* vals, int n) {
//     double sum = 0;
//     double mean = calc_mean(vals, n);
//     for (int i=0; i < n; i++)
//         sum += (((double) vals[i] - mean) * ((double) vals[i] - mean));
//     double var = sum / (double) (n - 1);
//     return sqrt(var);
// }


int main()
{
    double mhz = get_cpu_mhz(0);
    printf("CPU speed: %f mhz\n", mhz);

#ifndef SEND_SIGNALING
    printf("Not get signaled for send\n\n");
#endif

#ifndef SEND_INLINING
    printf("Not inlining for send\n\n");
#endif

    struct ibv_device **dev_list;
    struct ibv_device *ib_dev;
    struct ibv_context *context;
    struct ibv_pd *pd;
    int ret;

    /*1. Get the list of offload capable devices */
    int device_num;
    dev_list = ibv_get_device_list(&device_num);
    if (!dev_list)
    {
        perror("Failed to get devices list");
        exit(1);
    }
    printf("Available devices: %d\n", device_num);
    
    /* In this example, we will use the first adapter (device) we find on the list (dev_list[0]) . You may change the code in case you have a setup with more than one adapter installed. */
    ib_dev = dev_list[0];
    if (!ib_dev)
    {
        fprintf(stderr, "IB device not found\n");
        exit(1);
    }

    /* 2. Get the device context */
    /* Get context to device. The context is a descriptor and needed for resource tracking and operations */
    context = ibv_open_device(ib_dev);
    if (!context)
    {
        fprintf(stderr, "Couldn't get context for %s\n",
                ibv_get_device_name(ib_dev));
        exit(1);
    }

    ibv_free_device_list(dev_list);

    /* 3. Allocate Protection Domain */
    /* Allocate a protection domain to group memory regions (MR) and rings */
    pd = ibv_alloc_pd(context);
    if (!pd)
    {
        fprintf(stderr, "Couldn't allocate PD\n");
        exit(1);
    }

    /* 4. Create Complition Queue (CQ) */
    struct ibv_cq *send_cq;
    send_cq = ibv_create_cq(context, SQ_NUM_DESC, NULL, NULL, 0);
    if (!send_cq)
    {
        fprintf(stderr, "Couldn't create CQ %d\n", errno);
        exit(1);
    }

    struct ibv_cq *recv_cq;
    recv_cq = ibv_create_cq(context, RQ_NUM_DESC, NULL, NULL, 0);
    if (!recv_cq)
    {
        fprintf(stderr, "Couldn't create CQ %d\n", errno);
        exit(1);
    }


    /* 5. Initialize QP */
    struct ibv_qp *qp;
    struct ibv_qp_init_attr qp_init_attr = {
        .qp_context = NULL,

        /* report send completion to cq */
        .send_cq = send_cq,
        .recv_cq = recv_cq,
        .cap = {
            /* number of allowed outstanding sends without waiting for a completion */
            .max_send_wr = SQ_NUM_DESC,

            /* maximum number of pointers in each descriptor */
            .max_send_sge = 1,

            /* if inline maximum of payload data in the descriptors themselves */
            .max_inline_data = 512,

            .max_recv_wr = RQ_NUM_DESC,
            .max_recv_sge = 1,
        },

        .qp_type = IBV_QPT_RAW_PACKET,
        .sq_sig_all = 0,
    };

    /* 6. Create Queue Pair (QP) - Send Ring */
    qp = ibv_create_qp(pd, &qp_init_attr);
    if (!qp)
    {
        fprintf(stderr, "Couldn't create RSS QP\n");
        exit(1);
    }

    /* 7. Initialize the QP (receive ring) and assign a port */
    struct ibv_qp_attr qp_attr;
    int qp_flags;
    memset(&qp_attr, 0, sizeof(qp_attr));
    qp_flags = IBV_QP_STATE | IBV_QP_PORT;
    qp_attr.qp_state = IBV_QPS_INIT;
    qp_attr.port_num = 1;
    ret = ibv_modify_qp(qp, &qp_attr, qp_flags);

    if (ret < 0)
    {
        fprintf(stderr, "failed modify qp to init\n");
        exit(1);
    }
    memset(&qp_attr, 0, sizeof(qp_attr));

    /* 8. Move the ring to ready to send in two steps (a,b) */

    /* a. Move ring state to ready to receive, this is needed to be able to move ring to ready to send even if receive queue is not enabled */
    qp_flags = IBV_QP_STATE;
    qp_attr.qp_state = IBV_QPS_RTR;
    ret = ibv_modify_qp(qp, &qp_attr, qp_flags);
    if (ret < 0)
    {
        fprintf(stderr, "failed modify qp to receive\n");
        exit(1);
    }

    /* b. Move the ring to ready to send */
    qp_flags = IBV_QP_STATE;
    qp_attr.qp_state = IBV_QPS_RTS;
    ret = ibv_modify_qp(qp, &qp_attr, qp_flags);
    if (ret < 0)
    {
        fprintf(stderr, "failed modify qp to send\n");
        exit(1);
    }

    /* 9. Allocate Memory */
    int send_buf_size = ENTRY_SIZE * SQ_NUM_DESC; /* maximum size of data to be access directly by hw */
    void *send_buf;
    send_buf = malloc(send_buf_size);
    if (!send_buf)
    {
        fprintf(stderr, "Coudln't allocate memory\n");
        exit(1);
    }
    memset(send_buf, 0, send_buf_size);

    int recv_buf_size = ENTRY_SIZE * RQ_NUM_DESC; /* maximum size of data to be access directly by hw */
    void *recv_buf;
    recv_buf = malloc(recv_buf_size);
    if (!recv_buf)
    {
        fprintf(stderr, "Coudln't allocate memory\n");
        exit(1);
    }
    memset(recv_buf, 0, recv_buf_size);

    /* 10. Register the user memory so it can be accessed by the HW directly */
    struct ibv_mr *send_mr;
    send_mr = ibv_reg_mr(pd, send_buf, send_buf_size, IBV_ACCESS_LOCAL_WRITE);
    if (!send_mr)
    {
        fprintf(stderr, "Couldn't register mr\n");
        exit(1);
    }

    struct ibv_mr *recv_mr;
    recv_mr = ibv_reg_mr(pd, recv_buf, recv_buf_size, IBV_ACCESS_LOCAL_WRITE);
    if (!recv_mr)
    {
        fprintf(stderr, "Couldn't register mr\n");
        exit(1);
    }

    int n;
    struct ibv_sge send_sg_entry, recv_sg_entry;
    struct ibv_send_wr send_wr, *send_bad_wr;
    struct ibv_recv_wr recv_wr, *recv_bad_wr;
    int msgs_completed;
    struct ibv_wc wc;

    memset(&send_sg_entry, 0, sizeof(send_sg_entry));
    memset(&recv_sg_entry, 0, sizeof(recv_sg_entry));
    memset(&send_wr, 0, sizeof(send_wr));
    memset(&recv_wr, 0, sizeof(recv_wr));
    memset(&wc, 0, sizeof(wc));

    for (n=0; n < RQ_NUM_DESC; n++) {
        recv_sg_entry.addr = (uint64_t) recv_buf + ENTRY_SIZE*n;
        recv_sg_entry.length = ENTRY_SIZE;
        recv_sg_entry.lkey = recv_mr->lkey;

        recv_wr.wr_id = n;
        recv_wr.num_sge = 1;
        recv_wr.sg_list = &recv_sg_entry;
        recv_wr.next = NULL;
        ibv_post_recv(qp, &recv_wr, &recv_bad_wr);
    }


    // Create steeting rule
    struct raw_eth_flow_attr {
        struct ibv_flow_attr attr;
        struct ibv_flow_spec_eth spec_eth;
    } __attribute__((packed)) flow_attr = {
        .attr = {
            .comp_mask = 0,
            .type = IBV_FLOW_ATTR_NORMAL,
            .size = sizeof(flow_attr),
            .priority = 0,
            .num_of_specs = 1,
            .port = PORT_NUM,
            .flags = 0,
        },
        .spec_eth = {
            .type = IBV_FLOW_SPEC_ETH,
            .size = sizeof(struct ibv_flow_spec_eth),
            .val = {
                .dst_mac = MAC_SANCTUARY,
                .src_mac = MAC_MOSCOW,
                .ether_type = 0,
                .vlan_tag = 0,
            },
            .mask = {
                .dst_mac = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                .src_mac = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                .ether_type = 0,
                .vlan_tag = 0,   
            },
        }
    };

    struct ibv_flow_attr attr2 = {
        .comp_mask = 0,
        .type = IBV_FLOW_ATTR_SNIFFER,
        .size = sizeof(struct ibv_flow_attr),
        .priority = 0,
        .num_of_specs = 0,
        .port = PORT_NUM,
        .flags = 0
    };

    // Register steering rule
    struct ibv_flow *eth_flow;

    eth_flow = ibv_create_flow(qp, &flow_attr.attr);
    // eth_flow = ibv_create_flow(qp, &attr2);
    if (!eth_flow) {
        perror("Couldn't attach steering flow");
        exit(-1);
    }

    // prepare packets for send
    for (int i = 0; i < SQ_NUM_DESC; i++) {
        memcpy((void *) ((char *) send_buf + i*ENTRY_SIZE), packet, sizeof(packet));
    }

    // set values that will not change during loop
    recv_sg_entry.length = ENTRY_SIZE;
    recv_sg_entry.lkey = recv_mr->lkey;

    recv_wr.num_sge = 1;
    recv_wr.sg_list = &recv_sg_entry;
    recv_wr.next = NULL;

    send_sg_entry.lkey = send_mr->lkey;

    send_wr.num_sge = 1;
    send_wr.sg_list = &send_sg_entry;
    send_wr.next = NULL;
    send_wr.opcode = IBV_WR_SEND;
// #ifdef SEND_INLINING
//     send_wr.send_flags = IBV_SEND_INLINE;
// #endif

// #ifdef SEND_SIGNALING
//     send_wr.send_flags |= IBV_SEND_SIGNALED;
// #endif

    int iteration = SQ_NUM_DESC * 2;

    // int rtt_vals[SQ_NUM_DESC] = {0, };
    double rtt_vals[iteration];

    n = 0;
    // struct timespec t1, t2;
    cycles_t c1, c2;
    while (n < iteration) {
        // Send message to server
        send_sg_entry.addr = (uint64_t) send_buf + (n % SQ_NUM_DESC)*ENTRY_SIZE;
        send_sg_entry.length = sizeof(packet);
        send_wr.send_flags = 0;

#ifdef SEND_INLINING
        send_wr.send_flags |= IBV_SEND_INLINE;
#endif 

#ifdef SEND_SIGNALING
        send_wr.wr_id = n;
        send_wr.send_flags |= IBV_SEND_SIGNALED;
#else
        if ((n % (SQ_NUM_DESC / 2)) == 0) {
        // if ((n % SQ_NUM_DESC) == 0)
            send_wr.wr_id = n;
            send_wr.send_flags |= IBV_SEND_SIGNALED;
        }
#endif

        // clock_gettime(CLOCK_MONOTONIC, &t1);
        c1 = get_cycles();
        ret = ibv_post_send(qp, &send_wr, &send_bad_wr);
        if (ret < 0) {
            perror("Failed in post send");
            exit(-1);
        }

#ifdef SEND_SIGNALING
        do
            msgs_completed = ibv_poll_cq(send_cq, 1, &wc);
        while (msgs_completed <= 0);
        if (msgs_completed < 0) {
            perror("ibv_poll_cq()");
            exit(-1);
        }
        // printf("Sent message %d: %d bytes\n", (int) wc.wr_id, (int) sizeof(packet));
#else
        if  ((n % (SQ_NUM_DESC / 2)) == 0) {
        // if  ((n % SQ_NUM_DESC) == 0) {
            do
                msgs_completed = ibv_poll_cq(send_cq, 1, &wc);
            while (msgs_completed <= 0);
            if (msgs_completed < 0) {
                perror("ibv_poll_cq()");
                exit(-1);
            }
        }
        // printf("Sent message %d: %d bytes\n", n-1, (int) sizeof(packet));
#endif

        // Receive reply from server
        do
            msgs_completed = ibv_poll_cq(recv_cq, 1, &wc);
        while (msgs_completed <= 0);
        if (msgs_completed < 0) {
            perror("ibv_poll_cq()");
            exit(-1);
        }
        c2 = get_cycles();
        // printf("Received message %d: %d bytes\n", (int) wc.wr_id, wc.byte_len);
        // printf("RTT: %d nsec\n\n", time_diff_nsec(t1, t2));
        // printf("%d\n", time_diff_nsec(t1, t2));
        printf("%f\n", (c2 - c1) / mhz);
        rtt_vals[n] = (double) (c2 - c1) / mhz;
        // rtt_vals[n] = time_diff_nsec(t1, t2);
        
        recv_sg_entry.addr = (uint64_t) recv_buf + wc.wr_id*ENTRY_SIZE;
        recv_wr.wr_id = wc.wr_id;

        ibv_post_recv(qp, &recv_wr, &recv_bad_wr);

        // sleep(1);
        n++;
    }


    // printf("We are done\n");
    // printf("mean: %f\n", calc_mean(rtt_vals, SQ_NUM_DESC));
    // printf("stdev: %f\n", calc_stdev(rtt_vals, SQ_NUM_DESC));
    qsort(rtt_vals, iteration, sizeof(double), compare);
    printf("\nMedian: %f\n", median(rtt_vals, iteration));


    free(recv_buf);
    free(send_buf);

    return 0;
}
